;;
;; Main function for "czip"
;;
;; Author: CMN <md0claes@mdstud.chalmers.se>
;;

%include "system.inc"

%define DEFAULT_PERMS   0x180   ; (0600 octal)

[section .bss]
   infile  resd 1
   outfile resd 1
   unlink  resd 1

[section .data]
   USAGE     db 0xa,'Usage: ' 
   USAGELEN equ $-USAGE
   USAGE2    db ' [-d] <infile> <outfile>',0xa,0xa,'   -d    - Decompress infile',0xa,0xa
   USAGE2LEN equ $-USAGE2
   EQ        db 'Input and output is the same file!', 0xa
   EQLEN     equ $-EQ
   ERROUT    db 'Error opening outfile!',0xa
   ERROUTL   equ $-ERROUT
   ERRIN     db 'Error opening infile!',0xa
   ERRINL    equ $-ERRIN
   DECOMPR   db 0xa,'Error decompressing!',0xa, 'Is input file generated by this program?',0xa
   DECOMPRL  equ $-DECOMPR
   COMPRE    db 0xa, 'Compress error!',0xa
   COMPREL   equ $-COMPRE

[section .text]
   extern bit_open
   extern bit_close
   extern lzw_decompress
   extern lzw_compress
   global _start
extern debug

   _start:
        pop      ebx                 ; argc
        cmp      ebx, 3
        jl       near .usage         ; argc < 3
        mov      esi, [esp +4]       ; argv[1]
        cmp      [esi], word '-d'
        je       near .decompress
        mov      [unlink], esi
        
   ;; Compress infile
        mov      edi, [esp +8]       ; outfile, argv[2]
        call     strcmp
        cmp      eax, 1
        je       near .same_file

   ;; Open file to compress
        push     dword O_RDONLY
        push     dword [esp +8]      ; infile
        sys_open
        jc       near .err_open_in
        add      esp, 8         
        mov      [infile], eax

   ;; Open output file
        push     dword 0x00          ; Dummy
        push     dword 'w'           ; write only
        push     dword [esp +16]     ; outfile
        call     bit_open
        cmp      eax, 0
        je       near .err_open_out
        add      esp, 12
        mov      [outfile], eax
        push     eax         
		push     dword [infile]
        call     lzw_compress
        add      esp, 8
        or       eax, eax
        js       .compress_err
        push     dword [infile]      ; Close files
        sys_close
        add      esp, 4
        push     dword [outfile]
        call     bit_close
        add      esp, 4
        jmp      .finish

   ;; Error compressing
   .compress_err:
        push     dword COMPREL
        push     dword COMPRE
        push     dword STDOUT_FILENO
        sys_write
        add      esp, 12
        jmp      near .err

   ;; Decompress infile
   .decompress:
        mov      eax, [esp +8]
        mov      [unlink], eax
        mov      esi, [esp +8]       ; infile
        cmp      [esp +12], byte 0  
        je       near .usage         ; no outfile
        mov      edi, [esp +12]      ; outfile
        call     strcmp
        cmp      eax, 1
        je       near .same_file

   ;; Open outfile 
        push     dword DEFAULT_PERMS
        push     dword (O_WRONLY | O_CREAT | O_TRUNC) 
        push     dword [esp +20]
        sys_open
        jc       near .err_open_out
        add      esp, 12
        mov      [outfile], eax

   ;; Open file to decompress
        push     dword 'r'           ; read only
        push     dword [esp +12]     ; infile
        call     bit_open
        cmp      eax, 0
        je       near .err_open_in
        add      esp, 8
        mov      [infile], eax
        push     dword [outfile]
        push     dword eax
        call     lzw_decompress
        or       eax, eax
        js       .err_decompress
        push     dword [infile]
        call     bit_close
        add      esp, 4
        push     dword [outfile]
        sys_close
        add      esp, 4
        jmp      .finish

   ;; Error decompressing
   .err_decompress:
        push     dword DECOMPRL
        push     dword DECOMPR
        push     dword STDOUT_FILENO
        sys_write
        add      esp, 12
        jmp      .err

   ;; Error opening infile
   .err_open_in:
        add      esp, 8
        push     dword ERRINL
        push     dword ERRIN
        push     dword STDOUT_FILENO
        sys_write
        add      esp, 12
        jmp      .err
   
   ;; Error opening outfile
   .err_open_out:
        add      esp, 12
        push     dword ERROUTL
        push     dword ERROUT
        push     dword STDOUT_FILENO
        sys_write
        add      esp, 12
        jmp      .err
   
   ;; Input and output file equals
   .same_file:
        push     dword EQLEN
        push     dword EQ
        push     dword STDOUT_FILENO
        sys_write
        add      esp, 12
   
   ;; Return 1
   .err:
        push     dword 0x1
        sys_exit      
   
   ;; Unlink infile and exit(0)
   .finish:
        push     dword [unlink]
        sys_unlink
        add      esp, 4
        push     dword 0x0
        sys_exit
   
   ;; Print usage and exit.
   ;; This label could be alot shorter,
   ;; but it's nicer to print argv[0]  
   ;; than a fixed string.
   .usage:
        push     dword USAGELEN
        push     dword USAGE
        push     dword STDIN_FILENO
        sys_write
        add      esp, 12

        mov      esi, [esp]          ; argv[0]
        call     strlen
        push     dword edx
        push     dword [esp +4]      ; argv[0]
        push     dword STDOUT_FILENO
        sys_write
        add esp, 12
        
        push     dword USAGE2LEN
        push     dword USAGE2
        push     dword STDOUT_FILENO
        sys_write
        add esp, 12
        
        push dword 0x0
        sys_exit                     ; exit(0)


;;
;; Calculate length of string
;; string = esi
;; length = edx
;;
   strlen:
        xor      edx, edx            ; length = 0
        dec      edx

   .count:
        inc      edx
        cmp      [esi +edx], byte 0
        jnz      .count
   
   .finish:
        ret


;;
;; Compare two strings. 
;; return 1 If they are equal, 0 otherwise.
;;
;; string1 = esi
;; string2 = edi
;;
   strcmp:
        dec      esi
        dec      edi
        xor      eax, eax

   .cmp:
        inc      esi
        inc      edi
        mov      al, [esi]
        cmp      al, byte [edi]
        jne      .noequal
        cmp      [esi], byte 0
        je       .equal
		jmp      .cmp

   .noequal:
        xor      eax, eax
        jmp      .finish

   .equal:
        mov      eax, 1
   
   .finish:
        ret

